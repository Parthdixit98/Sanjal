<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Finger Controlled Particle Portrait</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: black;
}
video {
    display: none;
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

</head>
<body>

<video class="input_video"></video>

<script type="module">
import * as THREE from "three";

const COUNT = 20000;
const imagePaths = [
  "photo1.jpg",
  "photo2.jpg",
  "photo3.jpg",
  "photo4.jpg",
  "photo5.jpg"
];

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 150;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const sizes = new Float32Array(COUNT);

const targetPositions = new Float32Array(COUNT*3);
const targetColors = new Float32Array(COUNT*3);
const targetSizes = new Float32Array(COUNT);

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));
geometry.setAttribute("size", new THREE.BufferAttribute(sizes,1));

const material = new THREE.PointsMaterial({
  size:1.2,
  vertexColors:true,
  transparent:true,
  blending:THREE.AdditiveBlending,
  depthWrite:false
});

const particles = new THREE.Points(geometry,material);
scene.add(particles);

const hiddenCanvas = document.createElement("canvas");
const hCtx = hiddenCanvas.getContext("2d");

const imageTargets = [];

async function generateImageTarget(src){
  return new Promise(resolve=>{
    const img = new Image();
    img.src = src;
    img.onload = ()=>{
      const scale = 0.35;
      const w = img.width * scale;
      const h = img.height * scale;

      hiddenCanvas.width = w;
      hiddenCanvas.height = h;
      hCtx.drawImage(img,0,0,w,h);

      const data = hCtx.getImageData(0,0,w,h).data;

      const pos = new Float32Array(COUNT*3);
      const col = new Float32Array(COUNT*3);
      const siz = new Float32Array(COUNT);

      let ptr=0;

      for(let y=0;y<h;y+=2){
        for(let x=0;x<w;x+=2){
          const i = (y*w+x)*4;
          const r=data[i], g=data[i+1], b=data[i+2];
          const brightness=(r+g+b)/3;

          if(brightness>40 && ptr<COUNT){
            pos[ptr*3] = x - w/2;
            pos[ptr*3+1] = -(y - h/2);

            // slight 3D depth effect
            pos[ptr*3+2] = (brightness/255)*20 - 10;

            col[ptr*3] = r/255;
            col[ptr*3+1] = g/255;
            col[ptr*3+2] = b/255;

            siz[ptr] = 1.3;

            ptr++;
          }
        }
      }

      resolve({positions:pos, colors:col, sizes:siz});
    };
  });
}

async function loadImages(){
  for(let i=0;i<imagePaths.length;i++){
    const target = await generateImageTarget(imagePaths[i]);
    imageTargets.push(target);
  }
}

await loadImages();

function updateToImage(index){
  if(!imageTargets[index]) return;
  targetPositions.set(imageTargets[index].positions);
  targetColors.set(imageTargets[index].colors);
  targetSizes.set(imageTargets[index].sizes);
}

function animate(){
  requestAnimationFrame(animate);

  const pos = geometry.attributes.position.array;
  const col = geometry.attributes.color.array;
  const siz = geometry.attributes.size.array;

  for(let i=0;i<COUNT*3;i++){
    pos[i] += (targetPositions[i]-pos[i])*0.08;
    col[i] += (targetColors[i]-col[i])*0.08;
  }
  for(let i=0;i<COUNT;i++){
    siz[i] += (targetSizes[i]-siz[i])*0.08;
  }

  geometry.attributes.position.needsUpdate=true;
  geometry.attributes.color.needsUpdate=true;

  particles.rotation.y += 0.003; // subtle cinematic rotation

  renderer.render(scene,camera);
}
animate();


// =====================
// HAND TRACKING
// =====================

const videoElement = document.querySelector('.input_video');

const hands = new Hands({
  locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7
});

function countFingers(lm){
  let count=0;
  if(lm[8].y<lm[6].y) count++;
  if(lm[12].y<lm[10].y) count++;
  if(lm[16].y<lm[14].y) count++;
  if(lm[20].y<lm[18].y) count++;
  if(lm[4].x<lm[3].x) count++;
  return count;
}

hands.onResults((results)=>{
  if(results.multiHandLandmarks){
    results.multiHandLandmarks.forEach(lm=>{
      const fingers = countFingers(lm);
      if(fingers>=1 && fingers<=5){
        updateToImage(fingers-1);
      }
    });
  }
});

const cameraUtils = new Camera(videoElement,{
  onFrame:async ()=>{
    await hands.send({image:videoElement});
  },
  width:640,
  height:480
});
cameraUtils.start();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
