<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Finger Controlled Particle Portrait</title>

<style>
body{
    margin:0;
    overflow:hidden;
    background:black;
}

#videoContainer{
    position:fixed;
    bottom:20px;
    right:20px;
    width:240px;
    height:180px;
    border-radius:12px;
    overflow:hidden;
    border:2px solid cyan;
    box-shadow:0 0 20px cyan;
    z-index:999;
}

#output_canvas{
    width:100%;
    height:100%;
}

video{
    display:none;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>

<body>

<div id="videoContainer">
    <canvas id="output_canvas"></canvas>
</div>

<video class="input_video"></video>

<script>
const COUNT = 100000;

const imagePaths = [
    "1.jpg",
    "2.jpg",
    "3.jpg",
    "4.jpg",
    "5.jpg"
];

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 140;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const targetPositions = new Float32Array(COUNT*3);
const targetColors = new Float32Array(COUNT*3);

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
    size:0.7,
    vertexColors:true,
    blending:THREE.AdditiveBlending,
    transparent:true,
    depthWrite:false
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

const hiddenCanvas = document.createElement("canvas");
const ctx = hiddenCanvas.getContext("2d");
const imageTargets = [];

function generateImageTarget(src){
    return new Promise(resolve=>{
        const img = new Image();
        img.src = src;
        img.onload = ()=>{
            const scale = 0.20;
            const w = img.width * scale;
            const h = img.height * scale;

            hiddenCanvas.width = w;
            hiddenCanvas.height = h;
            ctx.clearRect(0,0,w,h);
            ctx.drawImage(img,0,0,w,h);

            const data = ctx.getImageData(0,0,w,h).data;

            const pos = new Float32Array(COUNT*3);
            const col = new Float32Array(COUNT*3);

            let ptr = 0;

            for(let y=0;y<h;y+=2){
                for(let x=0;x<w;x+=2){
                    const i=(y*w+x)*4;
                    const r=data[i];
                    const g=data[i+1];
                    const b=data[i+2];

                    if((r+g+b) > 60 && ptr < COUNT){

                        pos[ptr*3]   = x - w/2;
                        pos[ptr*3+1] = -(y - h/2);
                        pos[ptr*3+2] = (Math.random()-0.5)*1.5;

                        col[ptr*3]   = r/255;
                        col[ptr*3+1] = g/255;
                        col[ptr*3+2] = b/255;

                        ptr++;
                    }
                }
            }

            for(let i=ptr;i<COUNT;i++){
                pos[i*3]   = (Math.random()-0.5)*300;
                pos[i*3+1] = (Math.random()-0.5)*300;
                pos[i*3+2] = 0;

                col[i*3]   = 0;
                col[i*3+1] = 0;
                col[i*3+2] = 0;
            }

            resolve({positions:pos, colors:col});
        };
    });
}

async function loadImages(){
    for(let p of imagePaths){
        imageTargets.push(await generateImageTarget(p));
    }
}
loadImages();

function updateToImage(index){
    if(!imageTargets[index]) return;
    targetPositions.set(imageTargets[index].positions);
    targetColors.set(imageTargets[index].colors);
}

function randomSpace(){
    for(let i=0;i<COUNT;i++){
        targetPositions[i*3]   = (Math.random()-0.5)*300;
        targetPositions[i*3+1] = (Math.random()-0.5)*300;
        targetPositions[i*3+2] = 0;

        targetColors[i*3]   = 0.5;
        targetColors[i*3+1] = 0.7;
        targetColors[i*3+2] = 1;
    }
}

randomSpace();

function animate(){
    requestAnimationFrame(animate);

    const pos = geometry.attributes.position.array;
    const col = geometry.attributes.color.array;

    for(let i=0;i<COUNT*3;i++){
        pos[i] += (targetPositions[i]-pos[i])*0.08;
        col[i] += (targetColors[i]-col[i])*0.08;
    }

    geometry.attributes.position.needsUpdate=true;
    geometry.attributes.color.needsUpdate=true;

    renderer.render(scene,camera);
}
animate();

/* HAND TRACKING */

const videoElement = document.querySelector('.input_video');
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");

const hands = new Hands({
    locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands:1,
    modelComplexity:1,
    minDetectionConfidence:0.7
});

function countFingers(lm){

    let count = 0;

    if(lm[8].y < lm[6].y) count++;
    if(lm[12].y < lm[10].y) count++;
    if(lm[16].y < lm[14].y) count++;
    if(lm[20].y < lm[18].y) count++;

    if(Math.abs(lm[4].x - lm[2].x) > 0.05) count++;

    return count;
}

hands.onResults(results=>{
    canvasElement.width=240;
    canvasElement.height=180;

    canvasCtx.clearRect(0,0,240,180);
    canvasCtx.drawImage(results.image,0,0,240,180);

    if(results.multiHandLandmarks){
        for(const lm of results.multiHandLandmarks){

            drawConnectors(canvasCtx,lm,HAND_CONNECTIONS,{color:'cyan',lineWidth:3});
            drawLandmarks(canvasCtx,lm,{color:'#ffffff',radius:3});

            const fingers=countFingers(lm);

            if(fingers===0){
                randomSpace();
            }

            if(fingers===1) updateToImage(0);
            if(fingers===2) updateToImage(1);
            if(fingers===3) updateToImage(2);
            if(fingers===4) updateToImage(3);
            if(fingers===5) updateToImage(4);
        }
    } else {
        randomSpace();
    }
});

const cam = new Camera(videoElement,{
    onFrame:async()=>{
        await hands.send({image:videoElement});
    },
    width:640,
    height:480
});
cam.start();

window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
