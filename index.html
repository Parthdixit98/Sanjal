<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Finger Controlled Particle Portrait</title>

<style>
body{
    margin:0;
    overflow:hidden;
    background:black;
}
#cameraBox{
    position:fixed;
    bottom:20px;
    right:20px;
    width:220px;
    height:160px;
    border-radius:15px;
    overflow:hidden;
    box-shadow:0 0 20px cyan;
    z-index:10;
}
#output_canvas{
    width:100%;
    height:100%;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>

<body>

<div id="cameraBox">
    <canvas id="output_canvas"></canvas>
</div>

<script>

/////////////////////////
// THREE SETUP
/////////////////////////

const COUNT = 60000;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,2000);
camera.position.z = 500;   // increased so portrait fits

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

/////////////////////////
// PARTICLES
/////////////////////////

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);

const targetPositions = new Float32Array(COUNT*3);
const targetColors = new Float32Array(COUNT*3);

for(let i=0;i<COUNT;i++){
    positions[i*3] = (Math.random()-0.5)*800;
    positions[i*3+1] = (Math.random()-0.5)*800;
    positions[i*3+2] = 0;

    colors[i*3]=1;
    colors[i*3+1]=1;
    colors[i*3+2]=1;
}

geometry.setAttribute("position",new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color",new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
    size:1,
    vertexColors:true
});

const points = new THREE.Points(geometry,material);
scene.add(points);

/////////////////////////
// IMAGE LOADING
/////////////////////////

const imagePaths = ["1.jpg","2.jpg","3.jpg","4.jpg","5.jpg"];
const imageData = [];

function loadImages(){
    imagePaths.forEach(path=>{
        const img = new Image();
        img.src = path;
        img.onload = ()=>{
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img,0,0);
            imageData.push(ctx.getImageData(0,0,img.width,img.height));
        };
    });
}
loadImages();

/////////////////////////
// IMAGE TO PARTICLES
/////////////////////////

function updateToImage(index){

    if(!imageData[index]) return;

    const img = imageData[index];
    const data = img.data;
    const w = img.width;
    const h = img.height;

    let i = 0;

    for(let y=0;y<h;y+=3){
        for(let x=0;x<w;x+=3){

            if(i>=COUNT) break;

            const idx = (y*w + x)*4;

            const r = data[idx]/255;
            const g = data[idx+1]/255;
            const b = data[idx+2]/255;

            // scaled down so image fits screen
            targetPositions[i*3] = (x - w/2) * 0.6;
            targetPositions[i*3+1] = (h/2 - y) * 0.6;
            targetPositions[i*3+2] = 0;

            targetColors[i*3] = r;
            targetColors[i*3+1] = g;
            targetColors[i*3+2] = b;

            i++;
        }
    }
}

function randomSpace(){
    for(let i=0;i<COUNT;i++){
        targetPositions[i*3] = (Math.random()-0.5)*800;
        targetPositions[i*3+1] = (Math.random()-0.5)*800;
        targetPositions[i*3+2] = 0;

        targetColors[i*3]=1;
        targetColors[i*3+1]=1;
        targetColors[i*3+2]=1;
    }
}

/////////////////////////
// ANIMATION
/////////////////////////

function animate(){
    requestAnimationFrame(animate);

    for(let i=0;i<COUNT*3;i++){
        positions[i] += (targetPositions[i]-positions[i])*0.08;
        colors[i] += (targetColors[i]-colors[i])*0.08;
    }

    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;

    renderer.render(scene,camera);
}
animate();

/////////////////////////
// HAND DETECTION
/////////////////////////

const videoElement = document.createElement("video");
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");

canvasElement.width = 220;
canvasElement.height = 160;

let lastFinger = -1;

const hands = new Hands({
    locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }
});

hands.setOptions({
    maxNumHands:1,
    modelComplexity:1,
    minDetectionConfidence:0.7,
    minTrackingConfidence:0.7
});

hands.onResults(results=>{

    canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);
    canvasCtx.drawImage(results.image,0,0,canvasElement.width,canvasElement.height);

    let fingers = 0;

    if(results.multiHandLandmarks){
        for(const landmarks of results.multiHandLandmarks){

            drawConnectors(canvasCtx,landmarks,HAND_CONNECTIONS,{color:'#00FFFF',lineWidth:2});
            drawLandmarks(canvasCtx,landmarks,{color:'#FFFFFF',lineWidth:1});

            if(landmarks[8].y < landmarks[6].y) fingers++;
            if(landmarks[12].y < landmarks[10].y) fingers++;
            if(landmarks[16].y < landmarks[14].y) fingers++;
            if(landmarks[20].y < landmarks[18].y) fingers++;
            if(landmarks[4].x < landmarks[3].x) fingers++;
        }
    }

    if(fingers !== lastFinger){
        lastFinger = fingers;

        if(fingers===0) randomSpace();
        else if(fingers===1) updateToImage(0);
        else if(fingers===2) updateToImage(1);
        else if(fingers===3) updateToImage(2);
        else if(fingers===4) updateToImage(3);
        else if(fingers===5) updateToImage(4);
    }
});

const cameraMP = new Camera(videoElement,{
    onFrame: async()=>{
        await hands.send({image:videoElement});
    },
    width:640,
    height:480
});
cameraMP.start();

</script>
</body>
</html>
