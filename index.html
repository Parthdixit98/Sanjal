<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Finger Controlled Particle Portrait</title>

<style>
body{
    margin:0;
    overflow:hidden;
    background:black;
}

/* CAMERA BOX */
#videoContainer{
    position:fixed;
    bottom:20px;
    right:20px;
    width:240px;
    height:180px;
    border-radius:12px;
    overflow:hidden;
    border:2px solid rgba(0,255,255,0.6);
    box-shadow:0 0 20px rgba(0,255,255,0.6);
    z-index:1000;
}

#output_canvas{
    width:100%;
    height:100%;
}

video{
    display:none;
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

</head>
<body>

<div id="videoContainer">
  <canvas id="output_canvas"></canvas>
</div>

<video class="input_video"></video>

<script type="module">
import * as THREE from "three";

const COUNT = 20000;

const imagePaths = [
  "photo1.jpg.jpeg",
  "photo2.jpg.jpeg",
  "photo3.jpg.jpeg",
  "photo4.jpg.jpeg",
  "photo5.jpg.jpeg"
];

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 130;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const targetPositions = new Float32Array(COUNT*3);
const targetColors = new Float32Array(COUNT*3);

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
    size:1.2,
    vertexColors:true,
    blending:THREE.AdditiveBlending,
    transparent:true,
    depthWrite:false
});

const particles = new THREE.Points(geometry,material);
scene.add(particles);

const hiddenCanvas = document.createElement("canvas");
const hCtx = hiddenCanvas.getContext("2d");
const imageTargets = [];

async function generateImageTarget(src){
    return new Promise(resolve=>{
        const img = new Image();
        img.src = src;
        img.onload = ()=>{
            const scale = 0.23;
            const w = img.width * scale;
            const h = img.height * scale;

            hiddenCanvas.width = w;
            hiddenCanvas.height = h;
            hCtx.drawImage(img,0,0,w,h);

            const data = hCtx.getImageData(0,0,w,h).data;

            const pos = new Float32Array(COUNT*3);
            const col = new Float32Array(COUNT*3);

            let ptr=0;

            for(let y=0;y<h;y+=2){
                for(let x=0;x<w;x+=2){
                    const i = (y*w+x)*4;
                    const r=data[i];
                    const g=data[i+1];
                    const b=data[i+2];
                    const brightness=(r+g+b)/3;

                    if(brightness>40 && ptr<COUNT){
                        pos[ptr*3]   = x - w/2;
                        pos[ptr*3+1] = -(y - h/2);
                        pos[ptr*3+2] = (brightness/255)*15 - 7.5;
                        col[ptr*3]   = r/255;
                        col[ptr*3+1] = g/255;
                        col[ptr*3+2] = b/255;
                        ptr++;
                    }
                }
            }

            /* CENTERING FIX */
            let minY=Infinity, maxY=-Infinity;
            for(let i=0;i<ptr;i++){
                const yVal = pos[i*3+1];
                if(yVal<minY) minY=yVal;
                if(yVal>maxY) maxY=yVal;
            }

            const centerOffset = (minY+maxY)/2;

            for(let i=0;i<ptr;i++){
                pos[i*3+1] -= centerOffset;
            }

            resolve({positions:pos, colors:col});
        };
    });
}

async function loadImages(){
    for(let i=0;i<imagePaths.length;i++){
        const target = await generateImageTarget(imagePaths[i]);
        imageTargets.push(target);
    }
}
await loadImages();

function updateToImage(index){
    if(!imageTargets[index]) return;
    targetPositions.set(imageTargets[index].positions);
    targetColors.set(imageTargets[index].colors);
}

function animate(){
    requestAnimationFrame(animate);

    const pos = geometry.attributes.position.array;
    const col = geometry.attributes.color.array;

    for(let i=0;i<COUNT*3;i++){
        pos[i] += (targetPositions[i]-pos[i])*0.08;
        col[i] += (targetColors[i]-col[i])*0.08;
    }

    geometry.attributes.position.needsUpdate=true;
    geometry.attributes.color.needsUpdate=true;

    particles.rotation.y += 0.003;

    renderer.render(scene,camera);
}
animate();

/* ===== HAND TRACKING ===== */

const videoElement = document.querySelector('.input_video');
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");

const hands = new Hands({
  locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7
});

function countFingers(lm){
    let count=0;
    if(lm[8].y<lm[6].y) count++;
    if(lm[12].y<lm[10].y) count++;
    if(lm[16].y<lm[14].y) count++;
    if(lm[20].y<lm[18].y) count++;
    if(lm[4].x<lm[3].x) count++;
    return count;
}

hands.onResults((results)=>{
    canvasElement.width = 240;
    canvasElement.height = 180;

    canvasCtx.clearRect(0,0,240,180);
    canvasCtx.drawImage(results.image,0,0,240,180);

    if(results.multiHandLandmarks){
        for(const lm of results.multiHandLandmarks){
            drawConnectors(canvasCtx,lm,HAND_CONNECTIONS,{color:'#00ffff',lineWidth:3});
            drawLandmarks(canvasCtx,lm,{color:'#ffffff',radius:3});

            const fingers = countFingers(lm);
            if(fingers>=1 && fingers<=5){
                updateToImage(fingers-1);
            }
        }
    }
});

const cameraUtils = new Camera(videoElement,{
    onFrame:async()=>{
        await hands.send({image:videoElement});
    },
    width:640,
    height:480
});
cameraUtils.start();

window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
