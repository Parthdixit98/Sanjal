<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Finger Controlled Particle Portrait</title>

<style>
body{
    margin:0;
    overflow:hidden;
    background:black;
}

/* Camera box */
#cameraBox{
    position:fixed;
    bottom:20px;
    right:20px;
    width:220px;
    height:160px;
    border-radius:15px;
    overflow:hidden;
    box-shadow:0 0 20px cyan;
    z-index:10;
}
#output_canvas{
    width:100%;
    height:100%;
}

/* Message overlay */
#messageBox{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    color:white;
    font-size:50px;
    font-weight:bold;
    text-align:center;
    pointer-events:none;
    opacity:0;
    transition:opacity 0.4s ease;
    text-shadow:0 0 20px cyan;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>

<body>

<div id="messageBox"></div>

<div id="cameraBox">
    <canvas id="output_canvas"></canvas>
</div>

<script>

//////////////////// PARTICLE SYSTEM ////////////////////

const COUNT = 90000;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth/window.innerHeight,
    0.1,
    5000
);
camera.position.z = 900;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);
const targetPositions = new Float32Array(COUNT*3);
const targetColors = new Float32Array(COUNT*3);

geometry.setAttribute("position",new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color",new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
    size:1.3,
    vertexColors:true
});

const points = new THREE.Points(geometry,material);
scene.add(points);

function randomSpace(){
    for(let i=0;i<COUNT;i++){
        targetPositions[i*3]=(Math.random()-0.5)*2500;
        targetPositions[i*3+1]=(Math.random()-0.5)*2500;
        targetPositions[i*3+2]=0;

        targetColors[i*3]=1;
        targetColors[i*3+1]=1;
        targetColors[i*3+2]=1;
    }
}
randomSpace();

const imagePaths = ["1.jpg","2.jpg","3.jpg","4.jpg","5.jpg"];
const imageData = [];

imagePaths.forEach(path=>{
    const img = new Image();
    img.src = path;
    img.onload = ()=>{
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img,0,0);
        imageData.push(ctx.getImageData(0,0,img.width,img.height));
    };
});

function updateToImage(index){
    if(!imageData[index]) return;

    const img = imageData[index];
    const data = img.data;
    const w = img.width;
    const h = img.height;

    const visibleHeight = 2 * Math.tan((camera.fov * Math.PI / 180)/2) * camera.position.z;
    const visibleWidth = visibleHeight * camera.aspect;

    const scaleX = visibleWidth / w;
    const scaleY = visibleHeight / h;

    const scale = Math.min(scaleX, scaleY) * 0.85;

    for(let i=0;i<COUNT;i++){
        const px = Math.floor(Math.random()*w);
        const py = Math.floor(Math.random()*h);

        const id = (py*w + px)*4;

        targetPositions[i*3]   = (px - w/2) * scale;
        targetPositions[i*3+1] = (h/2 - py) * scale;
        targetPositions[i*3+2] = 0;

        targetColors[i*3]   = data[id]/255;
        targetColors[i*3+1] = data[id+1]/255;
        targetColors[i*3+2] = data[id+2]/255;
    }
}

function animate(){
    requestAnimationFrame(animate);

    for(let i=0;i<COUNT*3;i++){
        positions[i] += (targetPositions[i]-positions[i])*0.08;
        colors[i] += (targetColors[i]-colors[i])*0.08;
    }

    geometry.attributes.position.needsUpdate=true;
    geometry.attributes.color.needsUpdate=true;

    renderer.render(scene,camera);
}
animate();

//////////////////// HAND TRACKING ////////////////////

const videoElement = document.createElement("video");
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");

canvasElement.width = 220;
canvasElement.height = 160;

let lastFinger = -1;
let lastTextFinger = -1;

const hands = new Hands({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands:2,
    modelComplexity:1,
    minDetectionConfidence:0.7,
    minTrackingConfidence:0.7
});

hands.onResults(results=>{

    canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);
    canvasCtx.drawImage(results.image,0,0,canvasElement.width,canvasElement.height);

    const messageBox = document.getElementById("messageBox");

    let portraitFingers = 0;
    let textFingers = 0;

    if(results.multiHandLandmarks){

        results.multiHandLandmarks.forEach((lm,index)=>{

            drawConnectors(canvasCtx,lm,HAND_CONNECTIONS,{color:'#00FFFF',lineWidth:2});
            drawLandmarks(canvasCtx,lm,{color:'#FFFFFF',lineWidth:1});

            let count = 0;
            if(lm[8].y < lm[6].y) count++;
            if(lm[12].y < lm[10].y) count++;
            if(lm[16].y < lm[14].y) count++;
            if(lm[20].y < lm[18].y) count++;
            if(lm[4].x < lm[3].x) count++;

            if(index === 0){
                portraitFingers = count;
            }
            else if(index === 1){
                textFingers = count;
            }
        });
    }

    // FIRST HAND (unchanged)
    if(portraitFingers !== lastFinger){
        lastFinger = portraitFingers;

        if(portraitFingers===0) randomSpace();
        else if(portraitFingers===1) updateToImage(0);
        else if(portraitFingers===2) updateToImage(1);
        else if(portraitFingers===3) updateToImage(2);
        else if(portraitFingers===4) updateToImage(3);
        else if(portraitFingers===5) updateToImage(4);
    }

    // SECOND HAND (new feature)
    if(textFingers !== lastTextFinger){
        lastTextFinger = textFingers;

        if(textFingers === 1){
            messageBox.innerText = "This is the best freaking person";
            messageBox.style.opacity = 1;
        }
        else if(textFingers === 2){
            messageBox.innerText = "Absolutely iconic human being";
            messageBox.style.opacity = 1;
        }
        else if(textFingers === 3){
            messageBox.innerText = "Pure energy. Pure vibe.";
            messageBox.style.opacity = 1;
        }
        else if(textFingers === 4){
            messageBox.innerText = "Certified legend status";
            messageBox.style.opacity = 1;
        }
        else{
            messageBox.style.opacity = 0;
        }
    }

});

const cameraMP = new Camera(videoElement,{
    onFrame: async()=>{ await hands.send({image:videoElement}); },
    width:640,
    height:480
});
cameraMP.start();

</script>
</body>
</html>
