<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Finger Controlled Particle Portrait</title>
<style>
body { margin:0; overflow:hidden; background:black; }

#videoBox{
  position:fixed;
  bottom:20px;
  right:20px;
  width:220px;
  height:165px;
  border-radius:15px;
  overflow:hidden;
  box-shadow:0 0 20px cyan;
}

#output_canvas{
  width:100%;
  height:100%;
}
</style>
</head>
<body>

<div id="videoBox">
  <canvas id="output_canvas"></canvas>
</div>

<video class="input_video" style="display:none"></video>

<script type="module">

import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const COUNT = 18000;
let lastFingerCount = -1;

const imagePaths = [
  "1.jpg",
  "2.jpg",
  "3.jpg",
  "4.jpg",
  "5.jpg"
];

const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(
  window.innerWidth/-2,
  window.innerWidth/2,
  window.innerHeight/2,
  window.innerHeight/-2,
  1,1000
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
  size:2,
  vertexColors:true
});

const points = new THREE.Points(geometry,material);
scene.add(points);

const imageTargets = [];
const imageColors = [];

function loadImageToParticles(path,index){

  const img = new Image();
  img.src = path;

  img.onload = () => {

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = img.width;
    canvas.height = img.height;

    ctx.drawImage(img,0,0);

    const data = ctx.getImageData(0,0,img.width,img.height).data;

    const tempPositions = new Float32Array(COUNT*3);
    const tempColors = new Float32Array(COUNT*3);

    let i = 0;

    for(let y=0;y<img.height;y+=2){
      for(let x=0;x<img.width;x+=2){

        if(i>=COUNT) break;

        const indexPixel = (y*img.width + x)*4;

        const r = data[indexPixel]/255;
        const g = data[indexPixel+1]/255;
        const b = data[indexPixel+2]/255;

        tempPositions[i*3] = x - img.width/2;
        tempPositions[i*3+1] = img.height/2 - y;
        tempPositions[i*3+2] = 0;

        tempColors[i*3] = r;
        tempColors[i*3+1] = g;
        tempColors[i*3+2] = b;

        i++;
      }
    }

    imageTargets[index] = tempPositions;
    imageColors[index] = tempColors;
  }
}

imagePaths.forEach((p,i)=> loadImageToParticles(p,i));

function updateToImage(index){

  if(!imageTargets[index]) return;

  for(let i=0;i<COUNT;i++){
    positions[i*3] = imageTargets[index][i*3];
    positions[i*3+1] = imageTargets[index][i*3+1];
    positions[i*3+2] = 0;

    colors[i*3] = imageColors[index][i*3];
    colors[i*3+1] = imageColors[index][i*3+1];
    colors[i*3+2] = imageColors[index][i*3+2];
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
}

function randomSpace(){
  for(let i=0;i<COUNT;i++){
    positions[i*3] = (Math.random()-0.5)*window.innerWidth;
    positions[i*3+1] = (Math.random()-0.5)*window.innerHeight;
    positions[i*3+2] = 0;

    colors[i*3] = 1;
    colors[i*3+1] = 1;
    colors[i*3+2] = 1;
  }
  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
}

randomSpace();

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera.left = window.innerWidth/-2;
  camera.right = window.innerWidth/2;
  camera.top = window.innerHeight/2;
  camera.bottom = window.innerHeight/-2;
  camera.updateProjectionMatrix();
});

</script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const videoElement = document.querySelector(".input_video");
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");

canvasElement.width = 220;
canvasElement.height = 165;

function countFingers(landmarks){
  let count = 0;
  if(landmarks[8].y < landmarks[6].y) count++;
  if(landmarks[12].y < landmarks[10].y) count++;
  if(landmarks[16].y < landmarks[14].y) count++;
  if(landmarks[20].y < landmarks[18].y) count++;
  if(landmarks[4].x > landmarks[3].x) count++;
  return count;
}

const hands = new Hands({
  locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
  }
});

hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
});

hands.onResults(results=>{

  canvasCtx.save();
  canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);

  canvasCtx.drawImage(
    results.image,
    0,0,
    canvasElement.width,
    canvasElement.height
  );

  if(results.multiHandLandmarks){

    for(const landmarks of results.multiHandLandmarks){

      drawConnectors(canvasCtx,landmarks,HAND_CONNECTIONS,{color:"cyan",lineWidth:2});
      drawLandmarks(canvasCtx,landmarks,{color:"#ffffff",radius:3});

      const fingers = countFingers(landmarks);

      if(fingers !== lastFingerCount){

        lastFingerCount = fingers;

        if(fingers===0) randomSpace();
        if(fingers===1) updateToImage(0);
        if(fingers===2) updateToImage(1);
        if(fingers===3) updateToImage(2);
        if(fingers===4) updateToImage(3);
        if(fingers===5) updateToImage(4);
      }
    }
  }
  else{
    if(lastFingerCount !== 0){
      lastFingerCount = 0;
      randomSpace();
    }
  }

  canvasCtx.restore();
});

const cameraMedia = new Camera(videoElement,{
  onFrame: async ()=>{
    await hands.send({image:videoElement});
  },
  width:640,
  height:480
});
cameraMedia.start();

</script>

</body>
</html>
